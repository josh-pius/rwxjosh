### General
- [[Javap (CLI Utility)]] can be used to convert a [[Class (File Type) (Java)]] to [[Bytecode (Java)]]
- The first letter of the instruction usually indicates the type
	- `iconst_0` here `i` means integer

### Instructions
1. `iconst_0` -  Push the int constant 0 into the stack
2. `istore_1`- Store the int on top of the stack in local variable slot 1 
3. `iload_1` - Load the value from local variable slot 1 to stack
4. `bipush` -  Byte integer push, takes a byte size operand which it will push to stack
5. `if_icmpge` - Takes the top two values in the stack, if integer  top value is greater than  bottom value then  jump to instruction number passed as operand
6. `iinc` Integer increment, takes two operands, the local variable slot number and the amount to increment by 
7. `goto` Go back to an instruction index specified by the operand
8. `ldc` - Used to load [[#Data "Categories"|Category]] 1 constants from the [[Constant Pool (JVM Bytecode)]]. Takes single byte operand
9. `ldc_w` - Used to load [[#Data "Categories"|Category]] 1 constants from the [[Constant Pool (JVM Bytecode)]]. Takes double byte operand
10. `ldc2_w` - Used to load [[#Data "Categories"|Category]] 2 constants from the [[Constant Pool (JVM Bytecode)]] 
11. `dcmpg`- Compares the two doubles on top of the stack (not specifying what kind of comparision) and it puts the result on the stack
12. `ifge` - Used for example with `dcmpg` it takes the result of a comparison in the stack, check if it's greater than and then branches to a instruction specified by operand
13. `i2s` - We've been treating as an int but it's a short so truncate the value if there is an overflow
14. `aload_0` - loads the reference stored in local variable 0 onto the operand stack.
15. `invokevirtual`: Used for calling instance methods based on runtime type
16. `invokestatic`: Used for calling [[Static Methods (Java)]]
17. `invokedynamic`: Used for dynamic method invocation, primarily used in [[Lambda (Java)]] expressions, method handlers and [[Functional Interfaces (Java)]]
18. `invokeinterface`
19. `invokespecial`: The types of calls that don't fit into other invoke methods go here. The reason they don't fit is that in these cases there is [[Static Methods (Java)|static]] linking but it has a [[this (Java)]] pointer
	1. [[Constructor (Java)]] methods
	2. private methods
	3. superclass methods
	4. methods that require a direct invocation (bypassing virtual dispatch)
20. `new` - Object type is passed in, it allocates space on the [[Heap Memory (OS Concept)|heap]]
21. `putfield` - Used in [[setter (Java)]]
22. `getfield` - Used in [[getter (Java)]]
23. Array optcodes
	1. `newarray`
	2. `anewarray`
	3. `multianewarray`
	4. `Tastore` (eg `iastore`)
	5. `Taload` (eg `faload`)
24. [[switch statement (Java)]]
	1. `tableswitch`
	2. `lookupswitch`
25. untyped stack operations
	1. `pop`
	2. `pop2`
	3. `dup`
	4. `dup2`
	5. `dup_x1`
	6. `dup2_x1`
	7. `dup_x2`
	8. `dup2_x2`
	9. `swap`

### Why is it Called Bytecode
- It's [[Byte (Unit of Digital Information)|Byte]]-sized (8-bit) opcodes. 
- There are only 256 possible bytecode ($2^8=256$). Very conservative when it comes to adding new ones. The last one added was InvokeDynamic
- **Operands** though can be 8 or 16 bits

### Why learn Bytecode
- [[Bytecode (Java)]] is the lingua franca of the JVM/ java platform
	- It is the only common language in the JVM ecosystem. It's used by other languages and generated by libraries at runtime
- Tools like decompilers exists  that tries to reconstruct java code from bytecode
	- But bytecode is more expressive and it's not always possible to fully convert to java code
- Understanding [[Bytecode (Java)]] sets the foundation for further studies on things like
	- [[Bridge Methods (Java)]]
	- [[Type Erasure (Java)]]
	- Debugging
- It's low hanging fruit. It's much easier than assembly
	- Speaker has does 30 years of intel assembly and thinks you can learn Java bytecode in just a few hours 
### Architecture
- Architecture is a [[Stack Machine (Computer Science)]]. An example of how this works
	- You push one value into stack
	- Then you push another value into stack
	- Then you push an add operation. It removes the top two values adds them and then pushes the result back on the stack
- A benefit of the stack architecture is that CPU [[Register (Computer Hardware)]] details are abstracted from you. Also gives you free [[Liveliness Analysis (Compiler Design)]] since operand stack makes it explicit which values are still in use at any given point in execution
- Local variables
	- Apart from the stack values can also be stored in local variables
	- There are also opcodes that let you store results in local variables which can later be accessed in methods
- [[Constant Pool (JVM Bytecode)]]
	- The constant pool in JVM bytecode is a table that stores constants and symbolic references used by a Java class. It is a key part of the .class file structure and is used by the JVM at runtime for various operations.
	- Most constants of data types are part of the byte stream itself except [[long (Java Primitive)]] and [[double (Java Primitive)]] which are stored in the [[Constant Pool (JVM Bytecode)]]
### Example
- Example 1: [[int (Java Primitive)]] spin
```java
void spin() {
	int i;
	for (i=0; i< 100; i++){
		;//empty
	}
}
```
- Using [[Javac (CLI Utility)]] to convert you get this
```bytecode
void spin();
Code:
stack=2, locals=2,
args_size=1
0: iconst_0
1: istore_1
2: iload_1
3: bipush    100
5: if_icmpge 14
8: iinc      1,1
11: goto
14: return
```
- Before the instructions you have some critical information about the constraints of this method
	- the size of the stack (2 element high stack max)
	- the number of local variables (the variable i and the [[this (Java)]] pointer)
	- one argument, here it's the [[this (Java)]] pointer
- You see the instructions have bytecode indexes
- Details about the instruction can be found here [[#Instructions]]

- Example 2: [[double (Java Primitive)]] spin
```java
void spin() {
	double i;
	for (i=0.0; i< 100.0; i++){
		;//empty
	}
}
```

```
 void spin();
      stack=4, locals=3, args_size=1
         0: dconst_0
         1: dstore_1
         2: dload_1
         3: ldc2_w        #7                  // double 100.0d
         6: dcmpg
         7: ifge          17
        10: dload_1
        11: dconst_1
        12: dadd
        13: dstore_1
        14: goto          2
        17: return
```
- The `d` prefix in all the instructions indicates that it's working with doubles
- Stack size=4
	- Each value now takes up two slots (since [[double (Java Primitive)|double]] are bigger) so we need twice the stack size
- `ldc2_w` recall in the earlier example we used `bipush 100`.  For numbers under 256 (byte) you can just pass then in as operands
- For doubles though there's no way to specify the number in the byte stream
	- So the values is put in the [[Constant Pool (JVM Bytecode)]] and referenced by it's index `#7`
- Unlike the previous example you need two commands `dcmpg` and `ifge` to perform the same operation as `if_icmpge`

- Example 3: [[short (Java Primitive)]]  spin
```java
void sspin() {
	short i;
	for (i=0; i < 100; i++){
		;//empty
	}
}
```
- Bytecode is
```
 void spin();
      stack=2, locals=2, args_size=1
         0: iconst_0
         1: istore_1
         2: iload_1
         3: bipush        100
         5: if_icmpge     16
         8: iload_1
         9: iconst_1
        10: iadd
        11: i2s
        12: istore_1
        13: goto          2
        16: return

```
 - Almost exactly the same as int spin except that it has the additional `i2s` opcode
 - Recall [[#Some Types More Equal Than Others]]

- Example 4: [[Constant Pool (JVM Bytecode)]] fun
```java
void useManyNumeric(){
	int i = 100;
	int j = 1000000;
	long l1 = 1;
	long l2 = 0xffffffff;
	double d = 2.2;
	// ....do some calculations...
}
```
- [[Bytecode (Java)]] is
```
void useManyNumeric();
      stack=2, locals=9, args_size=1
         0: bipush        100
         2: istore_1
         3: ldc           #7                  // int 1000000
         5: istore_2
         6: lconst_1
         7: lstore_3
         8: ldc2_w        #8                  // long -1l
        11: lstore        5
        13: ldc2_w        #10                 // double 2.2d
        16: dstore        7
        18: return

```

- Example 5: Argument passing (virtual method)
```java
int addTwo(int i, int j) {
	return i + j;
}
```
- Bytecode is
```
int addTwo(int, int);
stack = 2, locals=3, args_size=3
0: iload_1
1: iload_2
2: iadd
3: ireturn
```
- Arguments are treated like local variables. In the local variables structure the values in order are `this`, `i` and `j`

- Example 6: argument passing (Static) 
```java
static int addTwoStatic(int i, int j) {
	return i + j;
}
```
- Bytecode is
```
static int
addTwoStatic(int, int);
flags: ACC_STATIC
Code:
stack=2, locals=2, args_size=2
0: iload_0
1: iload_1
2: iadd
3: ireturn
```
- Note how locals and args_size is 2 since [[this (Java)]] is not part of static methods 
- Notice the flag for static

- Example 7: method call (virtual)
```java
int add12and13() {
	return addTwo(12,13);
}
```
- [[Bytecode (Java)]] is
```
int add12and13();
Code:
stack=3, locals=1, args_size=1
0: aload0
1: bipush 12
2: bipush 13
5: invokevirtual #2 // Method addTwo:(II)
8: ireturn
```
- In this example `this` is in position zero of locals, it gets pushed into the stack with `aload0`, 12 and 13 are then pushed into the stack, `invokevirutal` with the method reference is then called which takes the two 3 values from the stack `this`, `12` and `13` and calls this method reference, the output is then put back on stack


- Example 8: method call (static)
```java
int add12and13() {
	return addTwoStatic(12,13);
}
```
- [[Bytecode (Java)]] is
```
int add12and13_static();
Code:
stack=2, locals=1, args_size=1
0: bipush 12
2: bipush 13
4: invokestatic #3 // Method addTwoStatic:(II)I
7: ireturn
```
- Same as the previous example but calls a static method

-  Example 9: Creating a new [[Object (Java Class)]]
```java
Object create() {
	return new Object();
}
```
- [[Bytecode (Java)]] is
```
java.lang.Object create();
stack=2, locals=1, args_size=1
0: new    #2 //class java/lang/Object
3: dup
4: invokespecial #1 //Method java/lang/Object."<init>":()V
7: areturn
```
- `new` allocates space for type Object in heap and pushes the [[this (Java)]] reference  to stack
- `dup` copies create a duplicate of the top value on the stack (the this pointer) and pushes into the stack
- `invokespecial #1` consumes the top value of stack the constructor is called here
- Example 10: Exception handler
	- Provided an example but didn't fully grasp how it worked (46:42)
### Data "Categories"
- Category 1
	- [[boolean (Java Primitive)]]
	- [[byte (Java Primitive)]]
	- [[char (Java Primitive)]]
	- [[short (Java Primitive)]]
	- [[int (Java Primitive)]]
	- [[float (Java Primitive)]]
	- [[References (Java)]]
	- returnAddress
- Category 2
	- [[long (Java Primitive)]]
	- [[double (Java Primitive)]]

### Some Types More Equal Than Others
- Types like [[int (Java Primitive)]] get a lot of opcodes but others like [[byte (Java Primitive)]] and [[short (Java Primitive)]] get way less
- This is because in most cases all those types can be treated as an int we only need to watch out for overflow type situations


### invokedynamic
- The most complicated among the `invoke` methods
- [[David Buck (Programmer)]] has a whole video dedicated to just this method
- https://www.youtube.com/watch?v=KhiECfzyVt0 #ToDigDeeper 

### Java Bytecode Crash Code
Source: https://youtu.be/e2zmmkc5xI0?si=Wx1ZbYxq9aNGUZw0 by [[Oracle Developers (Youtuber)]] by [[David Buck (Programmer)]]
- [[Javap (CLI Utility)]] is used to view the bytecode,
- Most of the examples that will get covered come from the [[JVM (Java)]] specification on oracle website


### Sources
-  https://youtu.be/e2zmmkc5xI0?si=Wx1ZbYxq9aNGUZw0 by [[Oracle Developers (Youtuber)]] by [[David Buck (Programmer)]]